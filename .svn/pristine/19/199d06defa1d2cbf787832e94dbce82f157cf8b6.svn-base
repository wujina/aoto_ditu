DELIMITER $$

DROP FUNCTION IF EXISTS `GET_FUN_NAME` $$
CREATE FUNCTION `GET_FUN_NAME`(P_FUN_ID INT)
RETURNS VARCHAR(64)
BEGIN
  DECLARE V_FUN_NAME VARCHAR(64);
  SELECT FUN_NAME INTO V_FUN_NAME FROM SYS_FUN WHERE FUN_ID = P_FUN_ID;
  RETURN V_FUN_NAME;
END $$

DROP FUNCTION IF EXISTS `GET_ORG_INHERITEDNAME` $$
CREATE FUNCTION `GET_ORG_INHERITEDNAME`(P_ORG_ID INT)
RETURNS VARCHAR(512)
BEGIN
  DECLARE V_ORG_INHERITEDNAME VARCHAR(512);
  SELECT INHERITED_NAME INTO V_ORG_INHERITEDNAME FROM SYS_ORG WHERE ORG_ID = P_ORG_ID;
  RETURN V_ORG_INHERITEDNAME;
END $$

DROP FUNCTION IF EXISTS `GET_ORG_NAME` $$
CREATE FUNCTION `GET_ORG_NAME`(P_ORG_ID INT)
RETURNS VARCHAR(64)
BEGIN
  DECLARE V_ORG_NAME VARCHAR(64);
  SELECT ORG_NAME INTO V_ORG_NAME FROM SYS_ORG WHERE ORG_ID = P_ORG_ID;
  RETURN V_ORG_NAME;
END $$

DROP FUNCTION IF EXISTS `GET_ORG_PARENTNAME` $$
CREATE FUNCTION `GET_ORG_PARENTNAME`(P_PARENT_ID INT)
RETURNS VARCHAR(64)
BEGIN
  DECLARE V_PARENT_NAME VARCHAR(64);
  SELECT ORG_NAME INTO V_PARENT_NAME FROM SYS_ORG WHERE ORG_ID = P_PARENT_ID;
  RETURN V_PARENT_NAME;
END $$

DROP FUNCTION IF EXISTS `GET_REAL_NAME` $$
CREATE FUNCTION `GET_REAL_NAME`(P_USER_ID INT)
RETURNS VARCHAR(64)
BEGIN
  DECLARE V_REAL_NAME VARCHAR(64);
  SELECT REAL_NAME INTO V_REAL_NAME FROM SYS_USER WHERE USER_ID = P_USER_ID;
  RETURN V_REAL_NAME;
END $$

DROP FUNCTION IF EXISTS `GET_USERNAME` $$
CREATE FUNCTION `GET_USERNAME`(P_USER_ID INT)
RETURNS VARCHAR(64)
BEGIN
  DECLARE V_USERNAME VARCHAR(64);
  SELECT USERNAME INTO V_USERNAME FROM SYS_USER WHERE USER_ID = P_USER_ID;
  RETURN V_USERNAME;
END $$

DROP FUNCTION IF EXISTS `GET_MENU_CHILDREN` $$
CREATE FUNCTION `GET_MENU_CHILDREN`(ROOT_ID INT)
RETURNS varchar(1000)
BEGIN
  DECLARE sTemp VARCHAR(1000);
  DECLARE sTempChd VARCHAR(1000);
  SET sTemp = '$';
  SET sTempChd =cast(ROOT_ID as CHAR);
  WHILE sTempChd is not null DO
    SET sTemp = concat(sTemp,',',sTempChd);
    SELECT group_concat(MENU_ID) INTO sTempChd FROM SYS_MENU where FIND_IN_SET(PARENT_ID,sTempChd)>0;
  END WHILE;
  RETURN sTemp;
END $$

DROP FUNCTION IF EXISTS `GET_ORG_CHILDREN` $$
CREATE FUNCTION `GET_ORG_CHILDREN`(ROOT_ID INT)
RETURNS varchar(1000)
BEGIN
  DECLARE sTemp VARCHAR(1000);
  DECLARE sTempChd VARCHAR(1000);
  SET sTemp = '$';
  SET sTempChd =cast(ROOT_ID as CHAR);
  WHILE sTempChd is not null DO
    SET sTemp = concat(sTemp,',',sTempChd);
    SELECT group_concat(ORG_ID) INTO sTempChd FROM SYS_ORG where FIND_IN_SET(PARENT_ID,sTempChd)>0;
  END WHILE;
  RETURN sTemp;
END $$

DROP FUNCTION IF EXISTS `GET_FUNC_CHILDREN` $$
CREATE FUNCTION `GET_FUNC_CHILDREN`(ROOT_ID INT)
RETURNS varchar(1000)
BEGIN
  DECLARE sTemp VARCHAR(1000);
  DECLARE sTempChd VARCHAR(1000);
  SET sTemp = '$';
  SET sTempChd =cast(ROOT_ID as CHAR);
  WHILE sTempChd is not null DO
    SET sTemp = concat(sTemp,',',sTempChd);
    SELECT group_concat(FUN_ID) INTO sTempChd FROM SYS_FUN where FIND_IN_SET(PARENT_ID,sTempChd)>0;
  END WHILE;
  RETURN sTemp;
END $$

DROP PROCEDURE IF EXISTS `CREATE_FUNC_CHILDREN` $$
CREATE PROCEDURE `CREATE_FUNC_CHILDREN`(IN ROOT_ID INT,IN ROOT_ID2 INT)
BEGIN
  DECLARE done INT DEFAULT 0;
  DECLARE b INT;
  DECLARE cur1 CURSOR FOR SELECT FUN_ID FROM SYS_FUN where PARENT_ID=ROOT_ID2;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
  insert into tmpLst values (ROOT_ID, ROOT_ID2);
  OPEN cur1;
  FETCH cur1 INTO b;
  WHILE done=0 DO
    CALL CREATE_FUNC_CHILDREN(ROOT_ID, b);
    FETCH cur1 INTO b;
  END WHILE;
  CLOSE cur1;
END $$

DROP PROCEDURE IF EXISTS `SELECT_FUNS_BY_PARENT_ID` $$
CREATE PROCEDURE `SELECT_FUNS_BY_PARENT_ID`(IN ROOT_ID INT, IN USER_ID INT)
BEGIN
  DECLARE done INT DEFAULT 0;
  DECLARE b INT;
  DECLARE cur1 CURSOR FOR SELECT FUN_ID FROM SYS_FUN where PARENT_ID=ROOT_ID AND DELETED=0 ORDER BY SORT_NUM;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
  CREATE TEMPORARY TABLE IF NOT EXISTS tmpLst
   (ID1 int, ID2 int);
  DELETE FROM tmpLst;
  SET @@SESSION.max_sp_recursion_depth=25;
  OPEN cur1;
  FETCH cur1 INTO b;
  WHILE done=0 DO
    CALL CREATE_FUNC_CHILDREN(b, b);
    FETCH cur1 INTO b;
  END WHILE;
  CLOSE cur1;  
  SELECT o.FUN_ID, o.FUN_NAME,o.PARENT_ID,o.SORT_NUM, o.LEVEL_NUM, 
    (SELECT CASE WHEN COUNT(1)=0 THEN 'open' ELSE 'closed' END FROM SYS_FUN WHERE DELETED = 0 AND parent_id = o.fun_id) AS state,
    USER_ID as USER_ID
  FROM SYS_FUN o WHERE EXISTS (
    SELECT t1.ID1 FROM tmpLst t1, 
    (SELECT DISTINCT f.FUN_ID FROM SYS_ROLE_USER u, SYS_ROLE_FUN f WHERE u.ROLE_ID = f.ROLE_ID AND u.USER_ID = USER_ID) t2 
    WHERE t1.ID1 = o.FUN_ID AND (t1.ID2 = t2.FUN_ID OR t1.ID2 < 0) 
  )
  AND o.DELETED = 0 AND o.PARENT_ID = ROOT_ID ORDER BY o.SORT_NUM ASC;  
END $$

DROP PROCEDURE IF EXISTS `SELECT_FUNS_FOR_TREE` $$
CREATE PROCEDURE `SELECT_FUNS_FOR_TREE`(IN ROOT_ID INT, IN USER_ID INT)
BEGIN
  DECLARE done INT DEFAULT 0;
  DECLARE b INT;
  DECLARE cur1 CURSOR FOR SELECT FUN_ID FROM SYS_FUN where PARENT_ID=ROOT_ID AND DELETED=0 ORDER BY SORT_NUM;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
  CREATE TEMPORARY TABLE IF NOT EXISTS tmpLst
   (ID1 int, ID2 int);
  DELETE FROM tmpLst;
  SET @@SESSION.max_sp_recursion_depth=25;
  OPEN cur1;
  FETCH cur1 INTO b;
  WHILE done=0 DO
    CALL CREATE_FUNC_CHILDREN(b, b);
    FETCH cur1 INTO b;
  END WHILE;
  CLOSE cur1;  
  SELECT o.FUN_ID, o.FUN_NAME, USER_ID as USER_ID
  FROM SYS_FUN o WHERE EXISTS (
    SELECT t1.ID1 FROM tmpLst t1, 
    (SELECT DISTINCT f.FUN_ID FROM SYS_ROLE_USER u, SYS_ROLE_FUN f WHERE u.ROLE_ID = f.ROLE_ID AND u.USER_ID = USER_ID) t2 
    WHERE t1.ID1 = o.FUN_ID AND (t1.ID2 = t2.FUN_ID OR t1.ID2 < 0) 
  )
  AND o.DELETED = 0 AND o.PARENT_ID = ROOT_ID ORDER BY o.SORT_NUM ASC;  
END $$